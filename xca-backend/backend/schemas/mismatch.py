"""
schemas/mismatch.py
"""

from pydantic import BaseModel, Field
from typing import Optional
from enum import Enum


class MismatchType(str, Enum):
    VALUE_DELTA      = "Value Delta"          # GSTR-1 vs GSTR-2B amount differs
    MISSING_IRN      = "Missing IRN"          # No e-Invoice IRN found
    EWAYBILL_MISSING = "e-Way Bill Missing"   # No EWB for goods transport
    EWAYBILL_EXPIRED = "e-Way Bill Expired"   # EWB expired before delivery
    GSTR1_NOT_FILED  = "GSTR-1 Not Filed"     # Seller never filed
    CIRCULAR_TXNS    = "Circular Transaction"  # Fraud ring detected
    FILING_DELAY     = "Filing Delay"         # Late GSTR-1 filing
    CANCELLED_INVOICE = "Cancelled Invoice"   # Buyer claimed on cancelled inv


class RiskLevel(str, Enum):
    LOW      = "LOW"
    MEDIUM   = "MEDIUM"
    HIGH     = "HIGH"
    CRITICAL = "CRITICAL"


# ── Single Hop in the ITC Chain ────────────────────────────────
class ChainHop(BaseModel):
    hop_name:   str           # "Invoice" / "IRN" / "e-Way Bill" / "GSTR-2B" / "Payment"
    status:     bool          # True = valid, False = broken
    detail:     Optional[str] = None   # Human-readable detail


# ── Single Mismatch Record ─────────────────────────────────────
class MismatchRecord(BaseModel):
    mismatch_id:    str            = Field(..., description="Unique ID eg. MM-001")
    invoice_no:     str
    irn:            Optional[str]  = None
    seller_gstin:   str
    seller_name:    str
    buyer_gstin:    str
    buyer_name:     str
    period:         str

    # The actual mismatch
    mismatch_type:  MismatchType
    risk_level:     RiskLevel

    # Values
    gstr1_value:    float = 0.0     # What seller reported
    gstr2b_value:   float = 0.0     # What buyer received
    delta:          float = 0.0     # Difference (money at risk)
    itc_blocked:    float = 0.0     # ITC that will be blocked

    # Chain status (each hop)
    chain_hops:     list[ChainHop] = []
    chain_broken_at: Optional[str] = None

    # AI audit note (generated by LLM)
    audit_note:     Optional[str]  = None


# ── Reconciliation Run Result ──────────────────────────────────
class ReconciliationResult(BaseModel):
    run_id:          str
    period:          str
    total_invoices:  int
    total_mismatches: int
    total_itc_at_risk: float

    # Breakdown by risk
    critical_count:  int = 0
    high_count:      int = 0
    medium_count:    int = 0
    low_count:       int = 0

    # Breakdown by type
    by_type:         dict[str, int] = {}

    mismatches:      list[MismatchRecord] = []


# ── Request: Trigger Reconciliation ───────────────────────────
class ReconcileRequest(BaseModel):
    period:         Optional[str]  = None   # None = all periods
    seller_gstin:   Optional[str]  = None   # None = all sellers
    buyer_gstin:    Optional[str]  = None   # None = all buyers
    run_audit_ai:   bool           = True   # Generate LLM audit notes?

    model_config = {
        "json_schema_extra": {
            "example": {
                "period": "Oct-2024",
                "seller_gstin": None,
                "buyer_gstin": None,
                "run_audit_ai": True
            }
        }
    }


# ── Filter Query Params for listing mismatches ─────────────────
class MismatchFilter(BaseModel):
    period:         Optional[str]       = None
    risk_level:     Optional[RiskLevel] = None
    mismatch_type:  Optional[MismatchType] = None
    min_delta:      Optional[float]     = None
    gstin:          Optional[str]       = None   # seller or buyer
    limit:          int                 = Field(default=50, le=200)
    offset:         int                 = 0
